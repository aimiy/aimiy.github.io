---
layout: post
title:  正则表达式
date:   2017-07-27 10:20:00 +0800
categories: 笔记
tag: 正则
---

* content
{:toc}

## 正则基础，速查记录

如果我们想要找到字符串The dog chased the cat中单词 the，我们可以使用下面的正则表达式: /the/gi

我们可以把这个正则表达式分成几段：

/ 是这个正则表达式的头部

the 是我们想要匹配的模式

/ 是这个正则表达式的尾部

g 代表着 global(全局)，意味着返回所有的匹配而不仅仅是第一个。

i 代表着忽略大小写，意思是当我们寻找匹配的字符串的时候忽略掉字母的大小写。

其实很简单，这里不把字符分为打印字符，非打印字符，特殊字符普通字符blabla那么多类了。

直接按照功能分，即用即查！便于理解，我把正则主要分三类，三部分限制，一是`限制输入的字符内容`，二是`限制相应字符的数量`，三是`限制出现的位置`。如果位多的话就一个个规则排排坐，捋出来。

### 限制字符内容

#### 打印字符

字符 | 描述
--|--
a-z，A-Z|字母
1-9|数字
\\d | 匹配0-9
\\D | 匹配非数字
\\w | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。
\\W | 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。
\\u4e00-\\u9fa5| 匹配中文

#### 非打印字符（看不见的字符）

你可以用正则表达式选择器的大写版本 来转化任何匹配。

举个例子：\s 匹配任何空白字符，\S 匹配任何非空白字符。
\w 在正则表达式中表示一个“字”（数字，字符，下划线）
字符 | 描述
-----|--
\\cx | 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\\f | 匹配一个换页符。等价于 \\x0c 和 \\cL。
\\n | 匹配一个换行符。等价于 \\x0a 和 \\cJ。
\\r | 匹配一个回车符。等价于 \\x0d 和 \\cM。
\\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 \[ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。
\\S | 匹配任何非空白字符。等价于 \[^ \\f\\n\\r\\t\\v]。
\\t | 匹配一个制表符。等价于 \\x09 和 \\cI。
\\v | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。

### 限定符（限制数量）

> 在JavaScript中, 数字选择器类似于: /\d/g。
> 在选择器后面添加一个加号标记+，例如：/\d+/g，它允许这个正则表达式匹配一个或更多数字。

字符 |描述
--|--
\* |0个或更多。要匹配 \* 字符，请使用 \\*。
\+ |1次或多次。要匹配 + 字符，请使用 \\+。
? |0次或1次。或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。
{n} |确定的 n 次。n 是一个非负整数。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,} |至少匹配n 次。n 是一个非负整数。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m} |最少匹配 n 次且最多匹配 m 次。m 和 n 均为非负整数，其中n <= m。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

* *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配
* {}是用来标记限定符的开始结束的

### 定位符（限制位置）

用来描述字符串或单词的边界

字符 |描述 | 注意
--|--|--
^ |匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 | 在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
$ |匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。要匹配 $ 字符本身，请使用 \$。
\\b |描述单词的前或后边界，即字与空格间的位置。|span class="marked">\b
\\B |表示非单词边界。|span class="marked">\B（字边界是单词和空格之间的位置）

> 注意：
>
> 不能将限定符与定位点一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。
>
> 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将^的这种用法与中括号表达式内的用法混淆。
>
> 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。

### 其他字符

其实就是把规则们包起来或者辨识出来
特别字符 |描述 | 注意
--|-- | --
( ) |标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。|()用圆括号将所有选择项括起来，相邻的选择项之间用\|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用.
. |匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \\. 。
[] |标记一个中括号表达式的开始，其实就是把限制字符范围的规则包起来。要匹配 [，请使用 \\[。
\ |将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
{} |标记限定符表达式的开始结束，其实就是把限定数量的表达式包起来。要匹配 {，请使用 \\{。
竖线 |指明两项之间的一个选择，也就是或的意思。要匹配 竖线，请使用\\竖线。

### ?:非捕获元

其中?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串

比如我原本查找域名的正则是

```js
let jsurl = filePath.match(/https?\:\/\/(.*?)\//)[0];
```

这个在匹配域名`http://test/test`时会抓取`http://test/`
但是有的时候，我不想要末尾的`/`只需要匹配的中间部分，使用非捕获元

```js
let jsurl = filePath.match(/https?\:\/\/(.*?)(?=\/)/)[0];
```

此时拿到的域名就是`http://test`

## 用实例捋一下正则使用

正则不常用就老忘，自己捋一下。

每次就对着查正则的表就好了，记住常用的表示符就没有问题。新人先看表，或者对照表一起推理实例。

### 仅输入20字符的字母

先找输入字符范围a-z,A-Z，再就是数量的限制1-20也就是{1,20}

于是正则表达式为

```js
/[a-zA-Z]{1,20}/
```

正则就是这样，相当简单！

### 正整数

字符范围，第一位不可为0，于是[1-9]，数量为1，不写。然后加入有第二位及以上，后面位数的字符范围就是\d，数量是0及以上。
于是`/[1-9]\d*/`
如果只是找出一串文字里的正整数，这个正则ok，但是限制输入的时候就不严谨！还需要限制开头不能为`-`，也就是第一位只可以是`1-9`，即

```js
/^[1-9]\d*/
```

## 手机号校验

输入字符范围0-9，限制必须11位。拆分为，第一位必为1，后面10位0-9
于是

```js
/1[0-9]{10}/
```

有时候限制需要更精确一些，也就是限制号段
目前号段规则如下，以后可能会变，正则就需要变化
第一位永远为1，`1`
第二位为3时，第三位可为0，1，2，3，4，5，6，7，8，9，`3\d`
第二位为4时，第三位可为5，6，7，8，9，`4[5-9]`
第二位为5时，第三位可为0，1，2，3，5，6，7，8，9，`5\d`
第二位为6时，第三位可为5，6，`6[56]`
第二位为7时，第三位可为0，1，2，3，4，5，6，7，8，`7[^9\D]`
第二位为8时，第三位可为0，1，2，3，4，5，6，7，8，9，`8\d`
第二位为9时，第三位可为1，8，9，`9[189]`

乍一看正则复杂，但是一点一点正则排排坐就非常简单了

```js
\1(3\d|4[5-9]|5\d|6[56]|7[^9\D]|8\d|9[189])\d{8}\
```

### 域名校验

域名中部可以由多个`字母数字-.`连续串联而成，但开头不能为`-`而且最后一个`.`后面必须为字母后缀，要求2-14位
`/([A-Za-z0-9][-A-Za-z0-9]*\.)+[A-Za-z]{2,14}/`

### 邮箱校验

邮箱的输入字符分为三部分
@前限制，第一个字符必须为数字字母下划线，后面的部分还可以为`-`，`+`，`.`这样的符号，即`\w[-\w.+]*`
@后面的部分其实就是域名
总的来说就是

```js
/\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]*\.)+[A-Za-z]{2,14}/
```

### 匹配章节标题

真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。
/^Chapter [1-9][0-9]{0,1}$/
参考：
[正则表][1]

  [1]: https://www.runoob.com/regexp/regexp-syntax.html
