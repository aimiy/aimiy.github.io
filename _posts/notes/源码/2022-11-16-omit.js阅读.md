---
layout: post
title:  omit.js源码阅读
date:   2021-01-21 11:00:00 +0800
categories: 笔记
tag: ts
---
* content
{:toc}

本文参加了由公众号[@若川视野](https://lxchuan12.gitee.io/) 发起的每周源码共读活动， [点击了解详情一起参与](https://juejin.cn/post/7079706017579139102)。
这是源码共读的第36期，链接：<https://juejin.cn/post/7118782469360320542>。

## 学习任务

>omit.js 剔除对象中的属性

>github仓库 github.com/benjycui/om… 主要看这个。然后写笔记写文章记录。

npm www.npmjs.com/package/omi…

这期比较简单，主要学会通过测试用例调试源码。 可以多关注怎么发布npm包的、commonjs、esm、测试用例 、ts 等（也可以不关注）。

建议克隆代码下来，关注测试用例，自己多通过测试用例调试，自己调试过才能够学会，感受更深一些。

关于如何调试看这篇：新手向：前端程序员必学基本技能——调试JS代码

根据大家问卷反馈情况，多设置一些相对简单的，先让大家参与进来，让大家觉得源码也不难。

最后大家没填问卷的，有空抽几分钟来填下源码共读活动问卷~你们的反馈至关重要wj.qq.com/s2/9304505/…

以下为选学

类似 TS Omit 参考文章 zhuanlan.zhihu.com/p/397398407
underscore.js 也有这个方法 omit underscorejs.org/docs/module…
lodash 也有 omit docs-lodash.com/v4/omit/

参考文章

若川说"可能是历史上最简单的一期omit.js"源码共读,但我学到了这些
看文章，看源码，交流讨论，写笔记发布在掘金/语雀。再在这篇文章下评论放上提交笔记的链接。

## 原理

源码还是比较简单的

```js
function omit(obj, fields) {
  // eslint-disable-next-line prefer-object-spread
  const shallowCopy = Object.assign({}, obj);
  for (let i = 0; i < fields.length; i += 1) {
    const key = fields[i];
    delete shallowCopy[key];
  }
  return shallowCopy;
}

export default omit;
```

通过`Object.assign()`将传入对象的值拷贝到新的空对象中，再对新目标对象进行剔除元素的处理。

### Object.assign

这里注意到shallowCopy是浅拷贝的意思。但是研究了下，

Object.assign是浅拷贝还是深拷贝的问题
即：第一级属性深拷贝，从第二级属性开始就是浅拷贝。

```js
//示例1  一层深拷贝
let obj = {a:1}
let newObj = Object.assign({},obj);
console.log(newObj); //{a: 1}
newObj.a=2;
console.log(obj); //{a:1}
console.log(newObj); //{a: 2}
 
 
//示例2  二层浅拷贝
let obj = {a:1,b:{name:"zhangsan"}}
let newObj = Object.assign({},obj);
console.log(newObj); //{a:1,b:{name:"zhangsan"}}
newObj.b.name="lisi";
console.log(obj); //{a:1,b:{name:"lisi"}}
console.log(newObj); //{a:1,b:{name:"lisi"}}
```

不全是

```js
let s = { a: { b: 1 }, c: 1 }
let target = Object.assign({}, s)
console.log(target) // { a: { b: 1 }, c: 1 }

s.a.b = 2
s.c = 3
console.log(s) // { a: { b: 2 }, c: 3 }
console.log(target) // { a: { b: 2 }, c: 1 }
```

**总的来说：**
`Object.assign()`拷贝的是属性值，如果源对象的属性值是一个指向对象的指针，那也只拷贝那个指针。

所以如果对象的属性值为基础类型，通过Object.assign()拷贝的那个属性而言是深拷贝。

如果对象的属性值为引用类型，通过Object.assign()拷贝的那个属性而言是浅拷贝。

## 依赖浏览

整个项目还是比较简单的，目的是为了查看如何搭建发布npm包。
查看相关的依赖

```json
"devDependencies": {
    "@umijs/fabric": "^2.2.2",
    "assert": "^1.4.1",
    "eslint": "^7.4.0",
    "father": "^2.29.5",
    "np": "^6.3.1",
    "rc-tools": "^6.3.3"
  }
```

### @umijs/fabric

初步看来是一个控制编码规范的工具。
readme比较短，复制过来。

一个包含 prettier，eslint，stylelint 的配置文件合集

A collection of configuration files containing prettier, eslint, stylelint

#### Use

安装

```bash
npm i @umijs/fabric --save-dev
yarn add @umijs/fabric -D
```

in `.eslintrc.js`

```js
module.exports = {
  extends: [require.resolve('@umijs/fabric/dist/eslint')],

  // in antd-design-pro
  globals: {
    ANT_DESIGN_PRO_ONLY_DO_NOT_USE_IN_YOUR_PRODUCTION: true,
    page: true,
  },

  rules: {
    // your rules
  },
};
```

in `.stylelintrc.js`

```js
module.exports = {
  extends: [require.resolve('@umijs/fabric/dist/stylelint')],
  rules: {
    // your rules
  },
};
```

in `.prettierrc.js`

```js
const fabric = require('@umijs/fabric');

module.exports = {
  ...fabric.prettier,
};
```

### assert

![assert](/styles/images/2022/assert.png)

### eslint

代码规范，不赘述

### father

![father](/styles/images/2022/father.png)

father并不是一个测试包，初步看来是一个功能比较强大的npm包研发工具。

### np

np是一个发布npm包的工具

### rc-tools

## 通过测试用例调试源码

查看package.json

```json
"scripts": {
    "start": "father doc dev --storybook",
    "build": "father doc build --storybook",
    "compile": "father build",
    "gh-pages": "father doc deploy",
    "prepublishOnly": "npm run compile && np --yolo --no-publish",
    "lint": "eslint .",
    "test": "father test",
    "coverage": "father test --coverage"
  },
```

通过`npm run test`执行测试用例

```bash
> omit.js@2.0.2 test
> father test

 PASS  tests/index.test.js
  omit
    √ should create a shallow copy (2ms)
    √ should drop fields which are passed in

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        50.254s
Ran all test suites.
```

测试代码很明显在tests目录下方

```js
import assert from 'assert';
import omit from '../src';

describe('omit', () => {
  it('should create a shallow copy', () => {
    const benjy = { name: 'Benjy' };
    const copy = omit(benjy, []);
    assert.deepEqual(copy, benjy);
    assert.notEqual(copy, benjy);
  });

  it('should drop fields which are passed in', () => {
    const benjy = { name: 'Benjy', age: 18 };
    assert.deepEqual(omit(benjy, ['age']), { name: 'Benjy' });
    assert.deepEqual(omit(benjy, ['name', 'age']), {});
  });
});
```

也就是说father集成了jest测试工具，使用了assert中的函数来测试
查看deepEqual

```js
function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}
```

是一个深层对比两个变量是否相同的函数

## 尝试构建包

关注怎么发布npm包的、commonjs、esm、测试用例 、ts 等（也可以不关注）

发现都是通过father来管理项目

项目中使用的是`"father": "^2.29.5",`版本，于是查看2分支
![father2](/styles/images/2022/father2.png)

但我使用最新版本试试

### 通过 create-father 快速创建一个 father 项目

```bash
npx create-father omit-f.js
```

选择了一系列npm包的配置后，自动生成了目录

![fatherlog](/styles/images/2022/fatherlog.png)

### 执行构建

```bash
npx father build
```

查看 dist 文件夹，可以看到构建产物已被生成出来

### 直接发布

执行 `npm whoami` 查看当前用户是否已经登录，如果未登录则执行 `npm login`检查 package.json 中的 NPM 包名及 publishConfig 是否符合预期.`npm publish`发布
![publishLog](/styles/images/2022/publishLog.png)
直接就发布成功了，工具还是很方便的。

### 开发

找到test命令
father自带一个test并且使用的是jest来测试，但是依赖里有一个`assert`
暂时没有理解，先往后看
