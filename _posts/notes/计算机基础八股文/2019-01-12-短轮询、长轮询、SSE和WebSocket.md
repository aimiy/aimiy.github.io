---
layout: post
title:  长/短 链接/轮询 SSE 和websocket 
date:   2019-01-12 11:00:00 +0800
categories: 笔记
tag: http
imgUrlArr: ["/styles/images/2022/TCPkeepalive保活示意图.png"]
---
* content
{:toc}

面试的时候被问到什么是长连接，websocket跟http有什么区别

## 短连接和长连接

### 短连接

http协议底层基于socket的tcp协议，每次通信都会新建一个TCP连接，即每次请求和响应过程都经历”三次握手-四次挥手“
优点：方便管理
缺点：频繁的建立和销毁连接占用资源

### 长连接

客户端和服务端之间只有一条TCP通信连接，以后所有的请求都使用这条连接，也称为持久连接。

优点：多次请求-响应基于一条连接，避免资源浪费。

缺点：客户端的数量增加，服务端承受的压力增大。对每个请求仍然要单独发header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

> HTTP keep-alive 的作用是，告知服务端持久化当前的 TCP 连接，不要立即断开，以便后续的 HTTP 请求复用它，也就是我们所说的「长连接」
> HTTP 的 keep-alive 是为了让 TCP 活久一点，而 TCP 本身也有一个 keepalive（注意没有横杠哦）机制。这是 TCP 的一种检测连接状况的保活机制，keepalive 是 TCP 保活定时器：TCP 建立后，如果闲置没用，服务器不可能白等下去，闲置一段时间[可设置]后，服务器就会尝试向客户端发送侦测包，来判断 TCP 连接状况，如果没有收到对方的回答（ACK包），就会过一会[可设置]再侦测一次，如果多次[可设置]都没回答，就会丢弃这个 TCP 连接

![TCPkeepalive保活示意图](/styles/images/2022/TCPkeepalive保活示意图.png)
（TCP keepalive 保活示意图）

### 总结

长短连接指的是客户端和服务端建立和保持TCP连接的机制。
不论是短连接还是长连接，都是客户端主动向服务端发请求，才能获悉数据，服务端是无法主动给客户端推送信息的。
服务端主动给客户端推送消息最简单的方式是采用轮询，即客户端每隔一段时间就向服务端发出一个询问，获取服务端最新的消息。最典型的应用就是聊天室。

## 短轮询和长轮询

### 短轮询

浏览器每隔一段时间向服务端发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。
优点：比较简单，易于理解；
缺点：由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。

### 长轮询

首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将 这个请求挂起，然后判断服务器端数据是否有更新。
如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。

优点：「明显减少了很多不必要的 http 请求次数」，相比之下节约了资源。

缺点：实现复杂，且连接挂起也会导致资源的浪费。

### 总结

短轮询和长轮询指的是客户端请求服务端，服务端给予响应的方式。
轮询的方式可以解决服务端主动向客户端推送消息的需求，但是轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。
为了更好的解决这个问题，于是出现了WebSocket

## WebSocket

### 简介

WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。

服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

可以发送文本，也可以发送二进制数据。

协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

websocket是长连接，是一个真的全双工，第一次tcp链路建立以后，后续所有数据双方都主动发送，不需要发送请求头，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。与HTTP长连接不同，websocket可以更灵活的控制连接关闭的时机，而不是HTTP协议的Keep-Alive一到，服务端立马就关闭（这样很不人性化）。

### 优点

建立在 TCP 协议之上，服务器端的实现比较容易。
与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
数据格式比较轻量，性能开销小，通信高效。
没有同源限制，客户端可以与任意服务器通信。
和 HTTP 一样都是建立在 TCP 协议之上，但只需一次 HTTP 握手，就能建立持久性连接，后续就不走 HTTP 了,而是 WebSocket 特有的数据帧
全双工通信，双向数据传输
数据格式轻量，且支持发送二进制数据，支持 ws 和加密的 wss

### 缺点

使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。

### 请求头特征

![业务中websocket图片示例](/styles/images/2022/业务中websocket图片示例.png)

* HTTP 必须是 1.1 GET 请求
* HTTP Header 中 Connection 字段的值必须为 Upgrade
* HTTP Header 中 Upgrade 字段必须为 websocket
* Sec-WebSocket-Key 字段的值是采用 base64 编码的随机 16 字节字符串
* Sec-WebSocket-Protocol 字段的值记录使用的子协议，比如 binary base64
* Origin 表示请求来源

### 响应头特征

* 状态码是 101 表示 Switching Protocols
* Upgrade / Connection / Sec-WebSocket-Protocol 和请求头一致
* Sec-WebSocket-Accept 是通过请求头的 Sec-WebSocket-Key 生成

## SSE server-Sent Events

SSE是一种可以主动从服务端推送消息的技术。
SSE的本质其实就是一个HTTP的长连接，只不过它给客户端发送的不是一次性的数据包，而是一个stream流，格式为
text/event-stream
。所以客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。
简单来说，SSE就是：

1）SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。
2）SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。
3）SSE 默认支持断线重连，WebSocket 需要自己实现。
4）SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。
5）SSE 支持自定义发送的消息类型。

SSE的技术原理如下图所示：

SSE基本的使用方法，可以参看 SSE 的API文档，地址是：developer.mozilla.org/en ... _ser…。
目前除了IE以及低版本的浏览器不支持，绝大多数的现代浏览器都支持SSE：

SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务 器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数 据包，而是一个数据流，会连续不断 地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就 是这样的例子。SSE 就是利用这种机 制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支 持。

优点
它相对于前面两种方式来说，不 需要建立过多的 http 请求，相比之下节约了资源。

上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。

## 总结对比

短连接轮询 | 长连接| websocket
--|--|--
很耗费 TCP 连接|HTTP keep-alive 开启后虽然 TCP 可以复用，但是 Header 重复的问题并没有解决.同时 HTTP keep-alive 还有一个有效期，有效期结束后服务端会发侦查帧探查 TCP 是否有效|和 HTTP 一样都是建立在 TCP 协议之上，但只需一次 HTTP 握手，就能建立持久性连接，后续就不走 HTTP 了,而是 WebSocket 特有的数据帧
而且 Header 重复发送|
且通过宏任务发起，受限于 Event Loop，无法保证及时性|
同时无效请求会很多|
