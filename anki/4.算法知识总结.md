# 前端面试八股文::4.算法知识总结

4.1 常用算法和数据结构总结

4.1.1 排序
冒泡排序

冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这

冒泡排序有两种优化方式。
一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发 生交换，则说明该序列已经为有序序列了。  因此我们不需要再执行之后的外层 循环，此时可以直接结束。

一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该 位置以后的序列都是已排好的序列，因此下 一轮循环中无需再去比较。

优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。

冒泡排序的平均时间复杂度为 O(n²)  ，最坏时间复杂度为 O(n²)  ，空间复杂度 为 O(1)  ，是稳定排序。
详细资料可以参考：《图解排序算法(一)》《常见排序算法 -  鸡尾酒排序 》《前 端笔试&面试爬坑系列---算法》 《前端面试之道》

// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序
if (!Array.isArray(array) | | length <= 1) return;

for (let i = 0; i < length - 1; i++) {

let minIndex = i; // 设置当前循环最小元素索引

for (let j = i + 1; j < length; j++) {

// 如果当前元素比最小元素索引，则更新最小元素索引

选择排序不管初始序列是否有序，时间复杂度都为 O(n2)。

选择排序的平均时间复杂度为 O(n2)  ，最坏时间复杂度为 O(n2)  ，空间复杂度 为 O(1)  ，不是稳定排序。
详细资料可以参考：  《图解排序算法(一)》

插入排序

直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的 有序序列中去，直到插完所有元素为止。

插入排序核心--扑克牌思想：  就想着自己在打扑克牌，接起来一张，放哪里无
所谓，再接起来一张，比第一张小，放左边，  继续接，可能是中间数，就插在

while (j -1 >= 0 && array[j - 1] > temp) {
array[j] = array[j - 1];
j--;
}

// 将找到的位置插入元素
array[j] = temp;
}

return array;}

// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序
if (!Array.isArray(array) | | length <= 1) return;

// 第一层确定增量的大小，每次增量的大小减半
for (let gap = parseInt(length >> 1); gap >= 1; gap = parseInt(gap >> 1)) {

// 对每个分组使用插入排序，相当于将插入排序的 1 换成了 n
for (let i = gap; i < length; i++) {
let temp = array[i];
let j = i;

插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分 组中，所以可能会造成相同元素位置的变化，  所以希尔排序是一个不稳定的排 序。

希尔排序的平均时间复杂度为 O(nlogn)  ，最坏时间复杂度为 O(n^s)  ，空间复 杂度为 O(1)  ，不是稳定排序。
详细资料可以参考：  《图解排序算法(二)之希尔排序》《数据结构基础 希尔排
序 之 算法复杂度浅析》
归并排序

let mid = parseInt(length >> 1), // 找到中间索引值
left = array.slice(0, mid), // 截取左半部分
right = array.slice(mid, length); // 截取右半部分

return merge(mergeSort(left), mergeSort(right)); // 递归分解后，进行排序合并}

function merge(leftArray, rightArray) {

let result = [],
leftLength = leftArray.length,

result.push(leftArray[il++]);
}

// 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。
while (ir < rightLength) {

result.push(rightArray[ir++]);
}

return result;}
归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节
点，树的每一层都是一个归并排序的过程，每 一层归并的时间复杂度为 O(n)，

function quickSort(array, start, end) {

let length = array.length;

// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序

if (!Array.isArray(array) | | length <= 1 | | start >= end) return;

let index = partition(array, start, end); // 将数组划分为两部分，并返回右部分 的第一个元素的索引值

quickSort(array, start, index - 1); // 递归排序左半部分

// 将比枢纽值小的值交换到 start 位置
array[start] = array[end];

// 移动 start 值，当 start 指针指向的值小于枢纽值时，start 指针向后移动
while (array[start] < pivot && start < end) {

start++;
}

// 将比枢纽值大的值交换到 end 位置，进入下一次循环
array[end] = array[start];

递归的次数为 logn ，然后每次划分的时间复杂 度为 O(n) ，所以最优的时间复 杂度为 O(nlogn) 。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。

当每次换分的结果为 n- 1  和 0  个元素时，最坏情况发生。划分操作的时间复杂

度为 O(n) ，递归的次数为 n- 1 ，所以最坏 的时间复杂度为 O(n²) 。所以当排序 序列有序的时候，快速排序有可能被转换为冒泡排序。
快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn) ，最坏的

// 如果不是数组或者数组长度小于等于 1，直接返回，不需要排序
if (!Array.isArray(array) | | length <= 1) return;

buildMaxHeap(array); // 将传入的数组建立为大顶堆

// 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆
for (let i = length - 1; i > 0; i--) {
swap(array, 0, i);
adjustMaxHeap(array, 0, i); // 将剩下的元素重新构建为大顶堆

iMax = iLeft;
}

// 如果右子元素存在，且右子元素大于最大值，则更新最大值索引

if (iRight < heapSize && array[iMax] < array[iRight]) {
iMax = iRight;
}

// 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值跟新为 被替换的值，继续检查它的子树

}}
// 交换数组中两个元素的位置 function swap(array, i, j) {
let temp = array[i];
array[i] = array[j];
array[j] = temp;}

建立堆的时间复杂度为 O(n) ，排序循环的次数为 n- 1 ，每次调整堆的时间复杂 度为 O(logn) ，因此堆排序的时间复杂度在 不管什么情况下都是 O(nlogn)。
堆排序的平均时间复杂度为 O(nlogn)  ，最坏时间复杂度为 O(nlogn)  ，空间复 杂度为 O(1)  ，不是稳定排序。
详细资料可以参考：  《图解排序算法(三)之堆排序》《常见排序算法 -  堆排序
(Heap Sort)》《堆排序中建堆过程时间复杂度 O(n)怎么来的？》《排序算法之 堆
排序 及其时间复杂度和空间复杂度》 《最小堆 构建、插入、删除的过程图解》
基数排序

let bucket = [],
max = array[0],
loop;

// 确定排序数组中的最大值
for (let i = 1; i < length; i++) {
if (array[i] > max) {
max = array[i];
}

if (str.length >= i + 1) {
let k = parseInt(str[str.length - 1 - i]); // 获取当前位的值，作为插入 的索引
bucket[k].push(array[j]);
} else {
// 处理位数不够的情况，高位默认为 0

bucket[0].push(array[j]);
}
}

array.splice(0, length); // 清空旧的数组

基数排序的平均时间复杂度为 O(nk)，k  为最大元素的长度，最坏时间复杂度为 O(nk) ，空间复杂度为 O(n)  ，是稳定 排序。
详细资料可以参考：《常见排序算法 -  基数排序》《排序算法之 基数排序 及
其时间复杂度和空间复杂度》

算法总结可以参考：《算法的时间复杂度和空间复杂度-总结》《十大经典排序 算法 (动图演示) 》 《各类排序算法的对比及实现》
快速排序相对于其他排序效率更高的原因

上面一共提到了8 种排序的方法，在实际使用中，应用最广泛的是快速排序。快
速排序相对于其他排序算法的优势在于在相同 数据量的情况下，它的运算效率

序的效率不如快速排序的主要原因。在计算机 中利用了多级缓存的机制，来解
决 cpu  计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是
基于局部性原 理，局部性原理简单来说就是，当前被访问过的数据，很有可能 在一段时间内被再次访问，这被称为时间局部性。还有就是当 前访问的数据， 那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计 算机缓存利用了局部性的原理 来对数据进行缓存，来尽可能少的减少磁盘的
I/O  次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于 空

间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔 很远的元素，这对于利用空间局部性来进行 数据缓存的计算机来说，它的很多 缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，
因此会明显 提高磁盘的 I/O  次数，并且由于堆排序的大量的无效比较，因此这
样就造成了堆排序执行效率的低下。而相对来快速排序来 说，它的排序每一次 都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原 理，因此它的执行效率更 高。简单来说就是在堆排序中获取一个元素的值所花 费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可 以看 出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决
定算法执行效率的还有内存读取这样的其 他的因素。
相关资料可以参考：  《为什么在平均情况下快速排序比堆排序要优秀？》《为
什么说快速排序是性能最好的排序算法？》

系统自带排序实现

每个语言的排序内部实现都是不同的。

对于 JS  来说，数组长度大于 10  会采用快排，否则使用插入排序。选择插入排

序是因为虽然时间复杂度很差，但是在数据 量很小的情况下和 O(N * logN)  相
差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。

稳定性

稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的 数 A  和 B ，在排序之前 A  在 B  的前面，  而经过排序之后，B  跑到了 A  的 前面，对于这种情况的发生，我们管他叫做排序的不稳定性。
稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM
的比较，我们对一个<ul>列表进行渲染，  当数据改变后需要比较变化时，不稳
定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损 耗。
排序面试题目总结

1.

快速排序在完全无序的情况下效果最好，时间复杂度为 O(nlogn) ，在有 序情况下效果最差，时间复杂度为 O(n^2)。
2.
3.

初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序， 归并排序，基数排序。
4.
5.

合并 m  个长度为 n  的已排序数组的时间复杂度为 O(nmlogm)。

6.
7.

外部排序常用的算法是归并排序。

8.
9.

数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大 小，不需要移动，时间复杂度趋近于 O(n)。
10.
11.

如果只想得到 1000 个元素组成的序列中第 5 个最小元素之前的部分排序 的序列，用堆排序方法最快。
12.
13.

插入排序和优化后的冒泡在最优情况 (有序) 都只用比较 n- 1  次。

14.

对长度为 n  的线性表作快速排序，在最坏情况下，比较次数为 n(n- 1)/2。

16.
17.

下标从 1 开始，在含有 n  个关键字的小根堆 (堆顶元素最小) 中，关键

字最大的记录有可能存储在 [n/2]+2  位置上。  因为小根堆中最大的数一 定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的 位置大于 [n/2]。
18.
19.

拓扑排序的算法，每次都选择入度为 0 的结点从图中删去，并从图中删除 该顶点和所有以它为起点的有向边。
20.
21.

任何一个基于" 比较" 的内部排序的算法，若对 n  个元素进行排序，则在 最坏情况下所需的比较次数 k  满足 2^k > n! ，  时间下界为 O(nlogn)
22.
23.

m  个元素 k  路归并的归并趟数 s=logk(m) ，代入数据：logk(100)≦3

24.
25.

对 n  个记录的线性表进行快速排序为减少算法的递归深度，每次分区后， 先处理较短的部分。
26.
27.

在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)

28.

4.1.2 树

二叉树相关性质

1.

节点的度：一个节点含有的子树的个数称为该节点的度；

2.
3.

叶节点或终端节点：度为零的节点；

4.
5.

节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此 类推。
6.
7.

树的高度或深度：树中节点的最大层次。

8.
9.

在非空二叉树中，第 i  层的结点总数不超过 2^(i- 1) ，i>=1。

10.
11.

深度为 h  的二叉树最多有 2^h- 1 个结点(h>=1) ，最少有 h  个结点。

12.

对于任意一棵二叉树，如果其叶结点数为 N0 ，而度数为 2 的结点总数为 N2 ，则 N0 = N2+1；
14.
15.

给定 N  个节点，能构成 h(N)  种不同的二叉树。h(N)为卡特兰数的第 N 项。(2n)!/(n!(n+1)!)。
16.
17.

二叉树的前序遍历，首先访问根结点，然后遍历左子树，最后遍历右子树。 简记根-左-右。
18.
19.

二叉树的中序遍历，首先遍历左子树，然后访问根结点，最后遍历右子树。 简记左-根-右。
20.
21.

二叉树的后序遍历，首先遍历左子树，然后遍历右子树，最后访问根结点。 简记左-右-根。
22.
23.

二叉树是非线性数据结构，但是顺序存储结构和链式存储结构都能存储。

24.
25.

一个带权的无向连通图的最小生成树的权值之和是唯一的。

27.

只有一个结点的二叉树的度为 0  。

28.
29.

二叉树的度是以节点的最大的度数定义的。

30.
31.

树的后序遍历序列等同于该树对应的二叉树的中序序列。

32.
33.

树的先序遍历序列等同于该树对应的二叉树的先序序列。

34.
35.

线索二叉树的线索实际上指向的是相应遍历序列特定结点的前驱结点和
后继结点，所以先写出二叉树的中序遍历序列：  debxac ，中序遍历中在 x 左边和右边的字符，就是它在中序线索化的左、右线索，即 b 、a  。
36.
37.

递归式的先序遍历一个 n  节点，深度为 d  的二叉树，需要栈空间的大 小为 O  (d) ，因为二叉树并不一定是平衡的，  也就是深度 d！=logn， 有可能 d>>logn 。所以栈大小应该是 O  (d)
38.
39.

一棵具有 N  个结点的二叉树的前序序列和后序序列正好相反 ，则该二 叉树一定满足该二叉树只有左子树或只有右子树，  即该二叉树一定是一 条链 (二叉树的高度为 N ，高度等于结点数) 。
40.
41.

引入二叉线索树的目的是加快查找结点的前驱或后继的速度。

42.
43.

二叉树线索化后，先序线索化与后序线索化最多有 1 个空指针域，而中序 线索化最多有 2 个空指针域。
44.
45.

不管是几叉树，节点数等于=分叉数+1

46.
47.

任何一棵二叉树的叶子结点在先序、中序和后序遍历中的相对次序不发生 改变。
48.
详细资料可以参考：  《n  个节点的二叉树有多少种形态》《数据结构二叉树知 识点总结》 《还原二叉树--已知先序中序或者后序中序》《树、森林与二叉树
的转换》
满二叉树

对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的 叶子节点都在同一层中，这样的二叉树称为满 二叉树。
完全二叉树

对于一棵具有 n  个节点的二叉树按照层次编号，同时，左右子树按照先左后右

编号，如果编号为 i  的节点与同样深度的满 二叉树中编号为 i 的节点在满二叉 树中的位置完全相同，则这棵二叉树称为完全二叉树。
性质：

1.

具有 n  个结点的完全二叉树的深度为 K =[log2n」+1(取下整数)

            2.

有 N  个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如 下关系：  若 I  为结点编号 (从 1 开始编号) 则 如果 I>1 ，则其父结点 的编号为 I/2；
4.
5.

完全二叉树，如果 2 *I < = N ，则其左儿子 (即左子树的根结点) 的编号 为 2* I ；若 2 *I > N ，则无左儿子；如 果 2* I + 1 < = N ，则其右儿子 的结点编号为 2 *I + 1 ；若 2* I + 1 > N ，则无右儿子。
6.

平衡二叉查找树具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高 度之差的绝对值不超过 1。

平衡二叉树是为了解决二叉查找树中出现链式结构 (只有左子树或只有右子树) 的情况，这样的情况出现后对我们的查找没有 一点帮帮助，反而增加了维护的 成本。
平衡因子使用两个字母来表示。第一个字母表示最小不平衡子树根结点的平衡因 子，第二个字母表示最小不平衡子树较高子树 的根结点的平衡因子。根据不同 的情况使用不同的方法来调整失衡的子树。
详细资料可以参考：  《平衡二叉树，AVL 树之图解篇》

是说这个比较过程是在内存中完成的，速度更快而已。
详细资料可以参考：  《漫画：什么是 B-  树？》
B+树

B+  树相对于 B-树有着更好的查找性能，根据 B-树我们可以知道，要想加快索

引速度的方法就是尽量减少磁盘 I/O  的次数。  B+  树相对于 B- 的主要变化是，
每个中间节点中不再包含卫星数据，只有叶子节点包含卫星数据，每个父节点都 出现在子节点 中，叶子节点依次相连，形成一个顺序链表。中间节点不包含卫 星数据，只用来作为索引使用，这意味着每一个磁盘页中能够 包含更多的索引
值。因此 B+  树的高度相对于 B-来说更低，所以磁盘的 I/O  次数更少。由于
叶子节点依次相连，并且包含 了父节点，所以可以通过叶子节点来找到对应的

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点 (NIL 节点) 。

4  每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有 两个连续的红色节点)
5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

当红黑树发生删除和插入导致红黑树不满足这些规则时，需要通过处理，使其重

1.

对应一组权重构造出来的 Huffman  树一般不是唯一的

2.
3.

Huffman  树具有最小的带权路径长度

4.
5.

Huffman  树中没有度为 1 的结点

7.

哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近

8.
9.

Huffman  树的带权路径长度 WPL  等于各叶子结点的带权路径长度之和

10.

show() {
console.log(this.value);
}}
实现二叉查找树类：

class BinarySearchTree {

constructor() {
this.root = null
}

insertNode(node, newNode) {

// 将插入节点的值与当前节点的进行比较，如果比当前节点小，则递归判断左子树，如果 比当前节点大，则递归判断右子树。

if (newNode.value < node.value) {
if (node.left === null) {
node.left = newNode;
} else {
this.insertNode(node.left, newNode);

preOrderTraverseNode(node) {
if (node !== null) {
node.show();

this.preOrderTraverseNode(node.left);
this.preOrderTraverseNode(node.right);
}
}

this.postOrderTraverseNode(this.root);
}

postOrderTraverseNode(node) {
if (node !== null) {
this.postOrderTraverseNode(node.left);
this.postOrderTraverseNode(node.right);
node.show();

let node = stack.pop();

// 执行节点操作
node.show();

// 判断节点是否还有左右子节点，如果存在则加入栈中，注意，由于中序遍历先序遍历 是先访问根
// 再访问左和右子节点，因此左右子节点的入栈顺序应该是反过来的
if (node.right) {
stack.push(node.right);
}

// 中序遍历是先左再根最后右
// 所以首先应该先把最左边节点遍历到底依次 push 进栈
// 当左边没有节点时，就打印栈顶元素，然后寻找右节点
while (stack.length > 0 | | node) {
if (node) {

stack.push(node);
node = node.left;
} else {
node = stack.pop();
node.show();

// 然后 push 右节点，最后 push 左节点

stack1.push(this.root);

while (stack1.length > 0) {

node = stack1.pop();

stack2.push(node);

if (node.left) {

// 寻找最小值，在最左边的叶子节点上
findMinNode(root) {
let node = root;

while (node && node.left) {

node = node.left;
}

return node;
}

}

if (node === null) {
return node;
}
if (value < node.value) {
return this.findNode(node.left, value);

if (node === null) {
return node;
}

if (value < node.value) {
node.left = this.removeNode(node.left, value);
return node;
} else if (value > node.value) {
node.right = this.removeNode(node.right, value);

// 第三种情况——一个有两个子节点的节点，去右子树中找到最小的节点，用它的值来替 换当前节点
// 的值，保持树的特性，然后将替换的节点去掉
let aux = this.findMinNode(node.right);

node.value = aux.value;
node.right = this.removeNode(node.right, aux);
return node;
}
}
求解二叉树中两个节点的最近公共祖先节点

(3) 该二叉树为普通二叉树，节点不含有指向父节点的指针。

这种情况下，我们可以从根节点出发，分别得到根节点到两个节点的路径。然后遍历两条路
径，直到遇到第一个不相同

的节点为止，这个时候该节点前面的那个节点则为两个节点的最近公共祖先节点。
详细资料可以参考：  《二叉树中两个节点的最近公共祖先节点》

4.1.3 链表

反转单向链表

while(current) {
next = current.next;
current.next = pre;
pre = current;
current = next;

}
return pre;};

4.1.4 动态规划

爬楼梯问题

if (n === 1) {
return 1;
}

if (n === 2) {
return 2;
}

return getClimbingWays(n - 1) + getClimbingWays(n - 2);}
使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度

}

if (n === 2) {
return 2;
}

if (map.has(n)) {
return map.get(n);
} else {
let value = getClimbingWays(n - 1) + getClimbingWays(n - 2);

if (n === 1) {
return 1;
}

return 2;
}

let a = 1,
b = 2,

主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。
function bigNumberAdd(number1, number2) {

carry = false; // 保留进位结果

// 将字符串转换为数组
number1 = number1.split("");
number2 = number2.split("");

// 返回最终结果
return result;}
详细资料可以参考：《JavaScript 实现超范围的数相加》《js  实现大整数加法》

(2). js  如何实现数组扁平化？

// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好function
flattenArray(array) {

if (!Array.isArray(array)) return;

let result = [];

function unique(array) {
if (!Array.isArray(array) | | array.length <= 1) return;

array.forEach(function (item) {
if (result.indexOf(item) === -1) {
result.push(item);
}
})

余数，一直这样递归下去，直到余数为 0 时，最后的被除数就是两个数的最大公约数。 function getMaxCommonDivisor(a, b) {
if (b === 0) return a;

return getMaxCommonDivisor(b, a % b);}

(6).  如何求两个数的最小公倍数？

基本思想是采用将两个数相乘，然后除以它们的最大公约数
function getMinCommonMultiple(a, b){
return a * b / getMaxCommonDivisor(a, b);}
详细资料可以参考：《百度 web  前端面试题之求两个数的最大公约数和最小公
倍数》

(7).实现 IndexOf  方法？

function indexFun(array, val) {
if (!Array.isArray(array)) return;

let length = array.length;

for (let i = 0; i < length; i++) {
if (array[i] === val) {
return i;
}
}

return -1;}

(8).  判断一个字符串是否为回文字符串？
function isPalindrome(str) {
let reg = /[\W_]/g, // 匹配所有非单词的字符以及下划线

newStr = str.replace(reg, "").toLowerCase(), // 替换为空字符并将大写字母转 换为小写
reverseStr = newStr.split("").reverse().join(""); // 将字符串反转

return reverseStr === newStr;}

(9).  实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()

(10).  使用 reduce  方法实现 forEach 、map 、filter

// forEach
function forEachUseReduce(array, handler) {
array.reduce(function (pre, item, index) {

handler(item, index);
});
}

// map

array.reduce(function (pre, item, index) {
if (handler(item, index)) {
result.push(item);
}
});

return result;
}
(11).  设计一个简单的任务队列，要求分别在 1,3,4  秒后打印出 "1", "2", "3"

setTimeout(() => {
item[0]();
}, item[1]);
})
}
}

(12).  如何查找一篇英文文章中出现频率最高的单词？

function findMostWord(article) {

// 合法性判断
if (!article) return;

let word = new RegExp(" " + item + " ", "g"),
num = article.match(word).length;

if (num > maxNum) {
maxNum = num;
maxWord = item;

}
}
});

return maxWord + "  " + maxNum;

时针每走一格为 30 度。

因此，时针走过的度数为 m *30 + n* 0.5，分针走过的度数为 n * 6。

因此时针与分针的夹角度数为 |m *30 + n* 0.5 - n *6 |;
答案：
因此时针与分针的夹角度数为 |m* 30 + n *0.5 - n* 6 |;
详细资料参考：  《面试智力题 —  时针与分针夹角度数问题》

4.2.2.  用 3 升，5 升杯子怎么量出 4 升水？

(1) 将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。

(2) 将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。

(3) 将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子 中就还剩 4 升水。

我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此
应该翻 a 和 2 两张牌。
4.2.5.  赛马问题，25  匹马，5  个赛道，最少几次能选出最快的三匹马？

我认为一共至少需要 7 次才能选出最快的三匹马。

(1) 首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由 于已经不可能成为前三了，因此可以直
接淘汰掉，那么我们现在还剩下了 15 匹马。

(2) 然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一 名，四五名的马以及它们对应组的其余

(3) 我们首先分析握了 8 次手的人， 由于他和除了自己配偶的每一个人都握了一次手，因此 其他人的握手次数都不为 0，因此只有
他的配偶握手次数为 0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。

(4) 我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了
8 次手的人和其余人也都握了一次手

，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可 以知道握手次数为 7 的人和握手次数
为 1 的人是配偶。

一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。

(1) 首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。

(2) 当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。

(3) 当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。

(4) 当 3 号绳子燃尽时，又过去了半小时， 以此一共加起来过去了一个小时十五分钟。

4.2.9.  有 7 克、2 克砝码各一个，天平一只，如何只用这些物品三次将 140 克

的盐分成 50、90 克各一份？

够得出小鸟飞行的距离。

4.2.11.  你有两个罐子，50 个红色弹球，50 个蓝色弹球，随机选出一个罐子，
随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划 中，得到红球的准确几率是多少？
第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近 75%，这是概率最大的方
法

4.2.12.  假设你有 8 个球，其中一个略微重一些，但是找出这个球的惟一方法是
将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？

最少两次可以称出。

首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。

第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后
一组的球进行比较即可。如

果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判 断。

4.2.13.  在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能
进门一次，你用什么方法来区分那个开关控制那一盏灯？

(1) 首先打开一盏灯 10 分钟，然后打开第二盏。

(2) 进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开 关打开的，而剩下的就是第三个开关打开的。

4.2.14.  他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，
而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们 每人怎样才能取回黑袜和白袜各两对呢？

将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜 和黑袜两对。

4.2.15.  有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子
与苹果混在一起。筐上的标签都是骗人的，  (就是说筐上的标签都是错的) 你 的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。
从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。

对应水果标签的筐的标签改为另一种水果。

另一种水果标签的框改为混合。

4.2.16.  一个班级 60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都
喜欢占比有多少？

(1) 首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种 球都喜欢的人的最大比例。

(2) 然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮 球，20%的人不喜欢排球，因此有最多
 90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。

因此三种球都喜欢的人占比为 10%-60%

4.2.17.  五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？

五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个 蛋。
更多的智力题可以参考：  《经典面试智力题 200+题和解答》

4.3 剑指 offer  思路总结

本部分主要是笔者在练习剑指 offer  时所做的笔记，如果出现错误，希望大家指
出！

4.3.1.  二维数组中的查找
题目：

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序 排序。请完成一个函数，输入这样的

一个二维数组和一个整数，判断数组中是否含有该整数。

思路：

(1) 第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时

使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”

str.replace(/\s/g,"%20")

4.3.3.  从尾到头打印链表

题目：

输入一个链表，从尾到头打印链表每个节点的值。

边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分 进行子树的递归构建。使用这种方式的
时间复杂度为 O(n)，空间复杂度为 O(logn)。

4.3.5.  用两个栈实现队列

题目：

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。  输入一个非递减排
序的数组的一个旋转，输出旋转数组的
最小元素。  例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。  NOTE：
给出的所有元素都大于 0，若数组大
小为 0，请返回 0。

思路：

(1) 我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋 转之后原始数组的值一定和一个值相
邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一

加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空 间复杂度为 O(1)。

4.3.8.  跳台阶

题目：

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少 种跳法。

思路：

跳台阶的问题是一个动态规划的问题，由于一次只能够跳 1 级或者 2 级，因此跳上 n 级台阶一

f(1) = 1
f(2) = f(2-1) + f(2-2)        //f(2-2) 表示 2 阶一次跳 2 阶的次数。
f(3) = f(3-1) + f(3-2) + f(3-3)

...

f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)

再次总结可得

| 1      ,(n=0 )

f(n) =

| 1

,(n=1 )

| 2*f(n-1),(n>=2)

输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。

一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整 数减去 1 时，最右边的一位 1 变为 0，它后
面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此 判断一个二进制中 1 的个数，我们可以判
断这个数可以经历多少次这样的过程。

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前 半部分，所有的偶数位于位于数组的后半
部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

思路：

由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素 进行遍历，每遇到一个奇数就将它加入到
奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。 这一种方法的时间复杂度为 O(n)，空间

输入一个链表，反转链表后，输出链表的所有元素。

通过设置三个变量 pre、current 和 next，分别用来保存前继节点、 从第一个节点开始向后遍历，首先将当
前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 置为当前节点，current 设置为 ne
xt 节点，实现下一次循环。

当前节点和后继结点。

pre，然后再将 pre 设

思路：

通过递归的思想来解决

第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。

第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相 同，当树 B 遍历结束时，结束比较。

4.3.18.  二叉树的镜像

题目：

则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

(1) 根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角 分别前进和后退一个单位，可以确定下一
次需要打印的数据范围。

(2) 使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依 次重复。

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
假设压入栈的所有数字均不相等。例如

序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列， 但 4,3,5,1,2 就不可能是该压栈序
列的弹出序列。  (注意：这两个序列的长度是相等的)

思路：

我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次 压入元素后我们首先判断该元素是否与出
栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中

题目：

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes， 否则输出 No。假设输入的数组的任意两
个数字都互不相同。

思路：

对于一个合法而二叉树的后序遍历来说，最末尾的元素为根元素。该元素前面的元素可以划分 为两个部分，一部分为该元素的左子树，

题目：

 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为 从树的根结点开始往下一直到叶结点所经                                                    过的结点形成一条路径。

 思路：

  通过对树进行深度优先遍历，遍历时保存当前节点的值并判断是否和期望值相等，如果遍历到 叶节点不符合要求则回退处理。

4.3.25.  复杂链表的复制

题目：

输入一个复杂链表 (每个节点中有节点值， 以及两个指针，一个指向下一个节点，另一个特殊 指针指向任意一个节点) ，返回结果为

复制后复杂链表的 head。  (注意，输出结果中请不要返回参数中的节点引用，否则判题程序
会直接返回空)

思路：

4.3.26.  二叉搜索树与双向链表

题目：

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结 点，只能调整树中结点指针的指向。

思路：

需要生成一个排序的双向列表，那么我们应该通过中序遍历的方式来调整树结构，因为只有中 序遍历，返回才是一个从小到大的排序
序列。

我们可以把一个字符串看做是两个部分，第一部分为它的第一个字符，第二部分是它后面的所 有字符。求整个字符串的一个全排列，可
以看做两步，第一步是求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字 符交换。第二步就是求后面所有字符的一
个全排列。因此通过这种方式，我们可以以递归的思路来求出当前字符串的全排列。

详细资料可以参考：  《字符串的排列》

4.3.28.  数组中出现次数超过一半的数字

题目：

左边，在左边继续寻找即可，反之
在右边寻找。这样可以只在 index 的一边寻找，而不用两边都排序，减少了一半排序时 间，这种方法的时间复杂度为 O(n)。

(3) 由于该数字的出现次数比所有其他数字出现次数的和还要多，因此可以考虑在遍历数组 时保存两个值：一个是数组中的一个数

字，一个是次数。当遍历到下一个数字时，如果下一个数字与之前保存的数字相同，则次 数加 1，如果不同，则次数减 1，如果
次数为 0，则需要保存下一个数字，并把次数设定为 1。 由于我们要找的数字出现的次数 比其他所有数字的出现次数之和还要大，
则要找的数字肯定是最后一次把次数设为 1 时对应的数字。该方法的时间复杂度为 O(n)， 空间复杂度为 O(1)。
详细资料可以参考：  《出现次数超过一半的数字》

此我们可以使用快速排序中的 part
ition 函数来实现。每一次选择一个枢纽值，将数组分为比枢纽值大和比枢纽值小的两个 部分，判断枢纽值的位置，如果该枢
纽值的位置为 k-1 的话，那么枢纽值和它前面的所有数字就是最小的 k 个数。如果枢纽 值的位置小于 k-1 的话，假设枢
纽值的位置为 n-1，那么我们已经找到了前 n 小的数字了，我们就还需要到后半部分去 寻找后半部分 k-n 小的值，进行划

分。当该枢纽值的位置比 k-1 大时，说明最小的 k 个值还在左半部分，我们需要继续对 左半部分进行划分。这一种方法的平
均时间复杂度为 O(n)。

(3) 第三种方法是维护一个容量为 k 的最大堆。对数组进行遍历时，如果堆的容量还没有达 到 k ，则直接将元素加入到堆中，这

思路：

(1) 第一种思路是直接暴力求解的方式，先以第一个数字为首往后开始叠加，叠加的过程中 保存最大的值。然后再以第二个数字为首
往后开始叠加，并与先前保存的最大的值进行比较。这一种方法的时间复杂度为 O(n^2)。

(2) 第二种思路是，首先我们观察一个最大和的连续数组的规律，我们可以发现，子数组一 定是以正数开头的，中间包含了正负数。

思路：

(1) 第一种思路是直接遍历每个数，然后将判断每个数中 1 的个数，一直叠加。

(2) 第二种思路是求出 1 出现在每位上的次数，然后进行叠加。

详细资料可以参考：  《从 1 到 n 整数中 1 出现的次数：O(logn)算法》

4.3.32.  把数组排成最小的数

题目：

把只包含质因子 2、3 和 5 的数称作丑数。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。  习惯上我们把 1 当做是第一个丑数。求
按从小到大的顺序的第 N 个丑数。

思路：

(1) 判断一个数是否为丑数，可以判断该数不断除以 2，最后余数是否为 1。判断该数不断除 以 3，最后余数是否为 1。判断不断除以
5，最后余数是否为 1。在不考虑时间复杂度的情况下，可以依次遍历找到第 N 个丑数。

4.3.34.  第一个只出现一次的字符

(2) 第二种思路是，首先对字符串进行一次遍历，将字符和字符出现的次数以键值对的形式 存储在 Map 结构中。然后第二次遍历时
，去 Map 中获取对应字符出现的次数，找到第一个只出现一次的字符。这一种方法的时 间复杂度为 O(n)。

4.3.35.  数组中的逆序对

题目：

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输 入一个数组，求出这个数组中的逆序对
的总数 P。

题目：

输入两个链表，找出它们的第一个公共结点。

(1) 第一种方法是在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个 链表上顺序遍历每个结点。如果在第二
个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是 就找到了它们的公共结点。如果第一
个链表的长度为 m，第二个链表的长度为 n。这一种方法的时间复杂度是 O(mn) 。

统计一个数字：在排序数组中出现的次数。例如输入排序数组 { 1, 2, 3, 3, 3, 3, 4, 5} 和数字 3 ， 由于 3 在这个数组中出
现了 4 次，因此输出 4 。

思路：

(1) 第一种方法是直接对数组顺序遍历的方式，通过这种方法来统计数字的出现次数。这种 方法的时间复杂度为 O(n)。

(2) 第二种方法是使用二分查找的方法， 由于数组是排序好的数组，因此相同数字是排列在

。

根节点的深度等于左右深度较大值加一，因此可以通过递归遍历来实现。

4.3.39.  平衡二叉树

题目：

输入一棵二叉树，判断该二叉树是否是平衡二叉树。

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一 次的数字。

(1) 第一种方式是依次遍历数组，记录下数字出现的次数，从而找出两个只出现一次的数字。

(2) 第二种方式，根据位运算的异或的性质，我们可以知道两个相同的数字异或等于 0，一个 数和 0 异或还是它本身。 由于数组中
的其他数字都是成对出现的，因此我们可以将数组中的所有数依次进行异或运算。如果只

思路：

维护一个正数序列数组，数组中初始只含有值 1 和 2，然后从 3 依次往后遍历，每遍历到一个 元素则将这个元素加入到序列数组中，然后
判断此时序列数组的和。如果序列数组的和大于所求值，则将第一个元素 (最小的元素弹出) 。 如果序列数组的和小于所求值，则继续
往后遍历，将元素加入到序列中继续判断。当序列数组的和等于所求值时，打印出此时的正数 序列，然后继续往后遍历，寻找下一个连
续序列，直到数组遍历完成终止。

右指针初始指向数组的最后一个元素
。然后首先判断两个指针指向的数字的和是否为 s ，如果为 s ，两个指针指向的数字就是我 们需要寻找的数字对。如果两数的和
比 s 小，则将左指针向左移动一位后继续判断。如果两数的和比 s 大，则将右指针向右移动 一位后继续判断。
详细资料可以参考：  《和为 S  的字符串》

4.3.43.  左旋转字符串

题目：

汇编语言中有一种移位指令叫做循环左移 (ROL) ，现在有个简单的任务，就是用字符串模拟 这个指令的运算结果。对于一个给定的

，正确的句子应该是“I am a student.” 。Cat 对一一的翻转这些单词顺序可不在行，你能帮
助他么？

通过空格将单词分隔，然后将数组反序后，重新拼接为字符串。

4.3.45.  扑克牌的顺子

题目：

LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有 2 个大王，2 个小王 ( 一副牌

缺，这个数组实际上还是连续的。

于是我们需要做 3 件事情：首先把数组排序，再统计数组中 0 的个数，最后统计排序之后的 数组中相邻数字之间的空缺总数。如
果空缺的总数小于或者等于 0 的个数，那么这个数组就是连续的：反之则不连续。最后，我
们还需要注意一点：如果数组中的非 0

数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则 不可能是顺子。
详细资料可以参考：  《扑克牌的顺子》

4.3.46.  圆圈中最后剩下的数字 (约瑟夫环问题)

求 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字 及条件判断语句 (A?B:C) 。

思路：

由于不能使用循环语句，因此我们可以通过递归来实现。并且由于不能够使用条件判断运算符， 我们可以利用 && 操作符的短路特
性来实现。

4.3.48.  不用加减乘除做加法

题目：

写一个函数， 求两个整数之和， 要求在函数体内不得使用 ＋、 －、×、÷ 四则运算符号。

思路：

通过位运算， 递归来实现。  

回该数字，否则返回 0。

首先需要进行符号判断，其次我们根据字符串的每位通过减 0 运算转换为整数和，依次根据位 数叠加。

4.3.50.  数组中重复的数字

题目：

额外的内存空间。

4.3.51.  构建乘积数组

题目：

给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A
[i+1]*...*A[n-1]。不能使用除法。

思路：

请实现一个函数用来匹配包括'. '和'*'的正则表达式。模式中的字符'. '表示任意一个字符， 而'*'表示它前面的字符可以出现任
意次 (包含 0 次) 。  在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa" 与模式"a.a"和"ab*ac*a"匹配，
但是与"aa.a"和"ab*a"均不匹配。

思路：

(1) 状态机思路 (待深入理解)

题目：

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两 个字符 "go" 时，第一个只出现一次
的字符是 "g" 。当从该字符流中读出前六个字符 "google" 时，第一个只出现一次的字符是 "l"。  输出描述：如果当前字符流
没有存在出现一次的字符，返回#字符。

思路：

同第 34 题

点就是环的入口节点。
详细资料可以参考： 《链表中环的入口结点》《《剑指 offer》——链表中环的
入口结点》

4.3.56.  删除链表中重复的结点

题目：

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返 回链表头指针。例如，链表 1->2->3-
>3->4->4->5 处理后为 1->2->5

给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有
两个分别指向左右子结点的指针以外，
还有一个指向父节点的指针。

这个问题我们可以分为三种情况来讨论。

第一种情况，当前节点含有右子树，这种情况下，中序遍历的下一个节点为该节点右子树的最 左子节点。因此我们只要从右子节点
出发，一直沿着左子节点的指针，就能找到下一个节点。

思路：

我们对一颗二叉树进行前序遍历的时候，是先访问左子节点，然后再访问右子节点。因此我们 可以定义一种对称的前序遍历的方式
，就是先访问右子节点，然后再访问左子节点。通过比较两种遍历方式最后的结果是否相同， 以此来判断该二叉树是否为对称二叉

。

4.3.59.  按之字形顺序打印二叉树 (待深入理解)

题目：

从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。

用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个 变量：一个变量表示在当前的层中还
没有打印的结点数，另一个变量表示下一次结点的数目。

4.3.61.  序列化二叉树 (待深入理解)

题目：

请实现两个函数，分别用来序列化和反序列化二叉树。

思路：

数组模拟

4.3.62.  二叉搜索树的第 K  个节点

题目：

给定一颗二叉搜索树，请找出其中的第 k 小的结点。
思路：

对一颗树首先进行中序遍历，在遍历的同时记录已经遍历的节点数，当遍历到第 k 个节点时， 这个节点即为第 k 大的节点。

4.3.63.  数据流中的中位数 (待深入理解)

题目：

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排
序之后位于中间的数值。如果数据

流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

题目：

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可 以从矩阵中的任意一个格子开始，每

一步可以在矩阵中向左， 向右， 向上， 向下移动一个格子。如果一条路径经过了矩阵中的某一 个格子，则该路径不能再进入该格子
。例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包 含"abcb"路径，因为字符串的
第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

4.3.66.  机器人的运动范围 (待深入理解)

有 n 个人，其中一个明星和 n-1 个群众，群众都认识明星，明星不认识任何群众，群众和群 众之间的认识关系不知道，现有一个
函数 foo(A, B)，若 A 认识 B 返回 true，若 A 不认识 B 返回 false，试设计一种算法找 出明星，并给出时间复杂度。

思路：

(1) 第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果 一个人谁都不认识，那么他就是明星。
这一种方法的时间复杂度为 O(n^2)。

排序。排序完成后我们使用两个指针分
别指向两个数组的首部，判断两个指针的和。如果和大于 0，则负数指针往后移动一个位置， 如果和小于 0，则正数指针往后移动
一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。
5.计算机网络知识总结
