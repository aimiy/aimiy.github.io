# 前端面试八股文::5.计算机网络知识总结

5.1 应用层

应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相
互传递报文，比如传递的报文的类型、格式、  有哪些字段等等。

5.1.1HTTP  协议

(1)概况

HTTP  是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式， 默认使用 80  端口。它使用 TCP  作为传 输层协议，保证了数据传输的可靠性。
HTTP  是一个无状态的协议，HTTP  服务器不会保存关于客户的任何信息。

HTTP  有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是

服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建 立 TCP  连接三次握手时所花费的时间。在 HTTP1.0  以前使用的非持续的连接，
但是可以在请求时，加上 Connection: keep-a live  来要求服务器不要关闭 TCP
连接。HTTP1. 1  以后默认采用的是持续的连接。 目前对于同一个域，大多数浏
览器支持 同时建立 6  个持久连接。

(2)HTTP  请求报文

HTTP  报文有两种，一种是请求报文，一种是响应报文。

HTTP  请求报文的格式如下：

GET / HTTP/1.1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept:
*/*

HTTP  请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟
一个实体主体。请求首部之后有一个空行，这 个空行不能省略，它用来划分首

Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
<body>Hello World</body>
</html>

HTTP  响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。

首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部
和实体首部在请求报文和响应报文中都可以设 置，区别在于请求首部和响应首 部。

常见的请求首部有 Accept  可接收媒体资源的类型、Accept-Charset  可接收的 字符集、Host  请求的主机名。
常见的响应首部有 ETag  资源的匹配信息，Location  客户端重定向的 URI。

常见的通用首部有 Cache-Control 控制缓存策略、Connection  管理持久连接。

常见的实体首部有 Content-Length  实体主体的大小、Expires  实体主体的过期 时间、Last-Modified  资源的最后修 改时间。
更多关于首部的资料可以查看：

问题。这个协议在 Chrome  浏览器上证明 可行以后，就被当作 HTTP/2  的基 础，主要特性都在 HTTP/2  之中得到继承。2015  年，HTTP/2  发布。
HTTP/2  主要有以下新的特性：

(1) 二进制协议

HTTP/2  是一个二进制协议。在 HTTP/1. 1  版中，报文的头信息必须是文本(ASCII

编码) ，数据体可以是文本，也可以是 二进制。HTTP/2  则是一个彻底的二进
制协议，头信息和数据体都是二进制，并且统称为"帧" ，可以分为头信息帧和数
据帧。  帧的概念是它实现多路复用的基础。
(2) 多路复用

HTTP/2  实现了多路复用，HTTP/2  仍然复用 TCP  连接，但是在一个连接里，
客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，
这样就避免了" 队头堵塞" 的问题。

(3) 数据流

HTTP/2  使用了数据流的概念，因为 HTTP/2  的数据包是不按顺序发送的，同一 个连接里面连续的数据包，可能属于不同的 请求。因此，必须要对数据包做标 记，指出它属于哪个请求。HTTP/2  将每个请求或回应的所有数据包，称为一个 数据流。每 个数据流都有一个独一无二的编号。数据包发送的时候，都必须标
记数据流 ID  ，用来区分它属于哪个数据流。

(4) 头信息压缩

附上所有信息。所以，请求的很多字段都是 重复的，比如 Cookie  和 User

Agent  ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响 速度。

HTTP/2  对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip

或 compress  压缩后再发送；另一方面，  客户端和服务器同时维护一张头信息
表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只 发送索引 号，这样就能提高速度了。
(5) 服务器推送

HTTP/2  允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使
用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟
时间。这里需要注意的是 http2  下服务器主动推送的是静态资源，和
WebSocket  以及使用

详细的资料可以参考：
教程》 SSE  等方式向客户端发送即时数据的推送是不同的。

《HTTP  协议入门》《HTTP/2  服务器推送(Server Push)

(6) HTTP/2  协议缺点

因为 HTTP/2  使用了多路复用，一般来说同一域名下只需要使用一个 TCP  连接。

由于多个数据流使用同一个 TCP  连接，遵 守同一个流量状态控制和拥塞控制。 只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的 所有数据都 会被阻塞。HTTP/2  出现的这个问题是由于其使用 TCP  协议的问题，
与它本身的实现其实并没有多大关系。

由于 TCP  本身存在的一些限制，Google  就开发了一个基于 UDP  协议的

QUIC  协议，并且使用在了 HTTP/3  上。  QUIC  协议在 UDP  协议上实现了多
路复用、有序交付、重传等等功能
详细资料可以参考：  《如何看待 HTTP/3  ？》

5.1.3 HTTPS  协议
(1) HTTP  存在的问题

1.

HTTP  报文使用明文方式发送，可能被第三方窃听。

2.
3.

HTTP  报文可能被第三方截取后修改通信内容，接收方没有办法发现报文 内容的修改。
4.
5.

HTTP  还存在认证的问题，第三方可以冒充他人参与通信。

6.

(2) HTTPS  简介

HTTPS  指的是超文本传输安全协议，HTTPS  是基于 HTTP  协议的，不过它会使

用 TLS/SSL  来对数据加密。使用 TLS/ SSL  协议，所有的信息都是加密的，第
三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方 会立 刻发现。它还配备了身份证书，防止身份被冒充的情况出现。
(3) TLS  握手过程

1.

第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成 的一个随机数、以及客户端支持的加密方法。
2.

3.

第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务 器的证书、以及一个服务器生成的随机数。
4.
5.

第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数
字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一 个前面所有内容的 hash  的值，用来供服务器检验。
6.
7.

第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提 供前面所有内容的 hash  值来供客户端检验。
8.
9.

第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数， 生成对话秘钥，以后的对话过程都使用这个秘钥 来加密信息。
10.

因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程 就毫无作用了。  这就要用到非对称加密的方法。
非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公 开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥 加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我 们通信的客户，  都可以使用我们提供的公钥对数据进行加密，这样我们就可以 使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点 就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会 造成等待时间过长的问题。

因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺 点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密 的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两 个方法各自存 在的问题。
但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一 定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将 他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他 用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我

DNS  协议提供的是一种主机名到 IP  地址的转换服务，就是我们常说的域名系 统。它是一个由分层的 DNS  服务器组成的分 布式数据库，是定义了主机如何 查询这个分布式数据库的方式的应用层协议。DNS  协议运行在 UDP  协议之上， 使用 53  号 端口。

(2) 域名的层级结构

域名的层级结构可以如下
主机名 .次级域名 .顶级域名 .根域名

# 即

1. 从"根域名服务器"查到"顶级域名服务器" 的 NS  记录和 A  记录 ( IP  地
。
2. 从"顶级域名服务器"查到"次级域名服务器" 的 NS  记录和 A  记录 ( IP 地址)。
3. 从"次级域名服务器"查出"主机名" 的 IP  地址。

比如我们如果想要查询www.baidu.com 的 IP  地址，我们首先会将请求发送到
本地的 DNS  服务器中，本地 DNS  服务 器会判断是否存在该域名的缓存，如 果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com  的 顶级域名 服务器的 IP  地址的列表。然后本地 DNS  服务器再向其中一个负  责 .com  的顶级域名服务器发送一个请求，负责 .com  的顶级域名服务器返回

负责 .baidu  的权威域名服务器的 IP  地址列表。然后本地 DNS  服务器再向其 中一个权威域名服 务器发送一个请求，最后权威域名服务器返回一个对应的主 机名的 IP  地址列表。
(4) DNS  记录和报文

1.

如果 Type = A ，则 Name  是主机名，Value  是主机名对应的 IP  地址。 因此一条记录为 A  的资源记录，提供了标 准的主机名到 IP  地址的映射。
2.
3.

如果 Type = NS ，则 Name  是个域名，Value  是负责该域名的 DNS  服 务器的主机名。这个记录主要用于 DNS  链式 查询时，返回下一级需要 查询的 DNS  服务器的信息。
4.

如果 Type = CNAME，则 Name  为别名，Value  为该主机的规范主机名。 该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告 诉查询主机去查询这个主机名的 IP  地址。主机别名主要是为了通过给一 些复杂的主机名提供 一个便于记忆的简单的别名。
6.
7.

如果 Type = MX，则 Name  为一个邮件服务器的别名，Value  为邮件服

务器的规范主机名。它的作用和 CNAME  是一 样的，都是为了解决规范 主机名不利于记忆的缺点。
8.

递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求， 最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请 求。                                                                      迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由 用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。               一般我们向本地 DNS  服务器发送请求的方式就是递归查询，因为我们只需要发 出一次请求，然后本地 DNS  服务器返回给我 们最终的请求结果。而本地 DNS
服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器
只返回单次 查询的结果，下一级的查询由本地 DNS  服务器自己进行。

(6) DNS  缓存

DNS  缓存的原理非常简单，在一个请求链中，当某个 DNS  服务器接收到一个 DNS  回答后，它能够将回答中的信息缓存在本 地存储器中。返回的资源记录中 的 TTL  代表了该条记录的缓存的时间。

(7) DNS  实现负载平衡

DNS  可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用 多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。当用户发起 网站域名的 DNS  请求的时候，DNS  服务器返回这个域名所对应的服务器 IP
地址的集合，但在 每个回答中，会循环这些 IP  地址的顺序，用户一般会选择
排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不 同的服务器 上，这样来实现负载均衡。
详细资料可以参考：  《DNS  原理入门》《根域名的知识》

5.2 传输层

传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只 工作在端系统中。

5.2.1 多路复用与多路分解

面向连接的多路复用和多路分解指的是 TCP  套接字的分配过程，一个 TCP  套 接字由一个四元组来标识，这个四元组包含了 源 IP  地址、源端口号、 目的地 址和目的端口号。因此，一个 TCP  报文段从网络中到达一台主机上时，该主机 使用全部 4  个 值来将报文段定向到相应的套接字。

5.2.2 UDP  协议

UDP  是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最 低限度的功能，除了复用/分解功能和少量的差 错检测外，它几乎没有对 IP  增 加其他的东西。UDP  协议适用于对实时性要求高的应用场景。

1.

使用 UDP  时，在发送报文段之前，通信双方没有握手的过程，因此 UDP

被称为是无连接的传输层协议。因为没有握手 过程，相对于 TCP  来说，
没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的 状态。

2.
3.

UDP  提供尽力而为的交付服务，也就是说 UDP  协议不保证数据的可靠 交付。
4.
5.

UDP  没有拥塞控制和流量控制的机制，所以 UDP  报文段的发送速率没 有限制。
6.
7.

因为一个 UDP  套接字只使用目的地址和目的端口来标识，所以 UDP  可 以支持一对一、一对多、多对一和多对多的交互 通信。
8.

UDP  首部小，只有 8  个字节。

10.

(1) UDP  报文段结构

UDP  报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口

1.

TCP  协议是面向连接的，在通信双方进行通信前，需要通过三次握手建 立连接。它需要在端系统中维护双方连接的状态信息。
2.
3.

TCP  协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的 数据传输服务。
4.

TCP  协议提供的是点对点的服务，即它是在单个发送方和单个接收方之 间的连接。
6.
7.

TCP  协议提供的是全双工的服务，也就是说连接的双方的能够向对方发 送和接收数据。
8.
9.

TCP  提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，
有助于减少数据包的丢失和减轻网络中的拥塞程度。

10.
11.

TCP  提供了流量控制机制，保证了通信双方的发送和接收速率相同。如
果接收方可接收的缓存很小时，发送方会降低发送 速率，避免因为缓存 填满而造成的数据包的丢失。

32  比特的序号和 32  比特的确认号，用与实现可靠数据运输服务。

16  比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节 的数量。

4  比特的首部长度字段，该字段指示了以 32  比特的字为单位的 TCP  首部的长 度。

6  比特的标志字段，ACK  字段用于指示确认序号的值是有效的，RST 、SYN  和

FIN  比特用于连接建立和拆除。设置 PSH  字 段指示接收方应该立即将数据交

在我看来，TCP  三次握手的建立连接的过程就是相互确认初始序号的过程，告
诉对方，什么样序号的报文段能够被正确接收。  第三次握手的作用是客户端对 服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道 自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器 接收，而出现错误的情况。

详细资料可以参考：《TCP  为什么是三次握手，而不是两次或四次？》《TCP  的
三次握手与四次挥手》
(3) TCP  四次挥手的过程

状态。如果收到 服务器的重发请求就重新发送确认报文段。服务器端收到客户 端的确认报文段后就进入 CLOSED  状态，这样全双工的连接就被 释放了。

TCP  使用四次挥手的原因是因为 TCP  的连接是全双工的，所以需要双方分别释
放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接 处于的是半释放的状态。

最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务 器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。
详细资料可以参考：
《前端面试之道》
(4) ARQ 协议

连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。
它通过连续发送一组分组，然后再等待对分组的 确认回答，对于如何处理分组  中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。

1. 滑动窗口协议
使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经 发送并确认了的分组，发送窗口中包含了已经发 送但未确认的分组和允许发送

但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送 方向接收方发送分 组时，会依次发送窗口内的所有分组，并且设置一个定时器， 这个定时器可以理解为是最早发送但未收到确认的分组。如果在定 时器的时间 内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后 一个位置，此时如果还有已发送但没 有确认的分组，则重新设置定时器，如果 没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确 认的分 组。
接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分 组的肯定回答。如果收到了一个乱序的分组，那 么接方会直接丢弃，并返回一

1. 选择重传协议

(5) TCP  的可靠运输机制

TCP  的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。

TCP  协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并
确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但 还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当 发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个 定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。  如果在定 时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑 动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则 重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有 已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发

会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的 大小，发送方根据 接收方的接收窗口的大小来调整发送窗口的大小，以此来达 到控制发送速率的目的。
(7) TCP  的拥塞控制机制

TCP  的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，
如果网络处于拥塞的状态，发送方就减小发送的 速率，这样一方面是为了避免 继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段 丢失。

TCP  的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和 快速恢复。

5.2.4 网络层

网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主 要的组件，一个 IP  网际协议，一个是路由选 择协议。

IP  网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会 被分配一个 IP  地址，常用的比如 IPV4  使用 32  位来分配地址，还有 IPv6  使 用 128  位来分配地址。
路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路 由选择算法等。

(1) 从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会 产生影响的场景， 比如说请求一个网
页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。 比如注册用户 这一类的操作。

(2) 因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。

(3) 从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分 一般为向服务器发送的数据。

(4) 但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post

只要客户端给出这个编号，服务器

如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有 的浏览器都支持这一种方法。但是
这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡
被转移到了其他的服务器上，那
么就无法恢复对话。

另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客 户的，这个 ticket 是加密的
，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我 们的请求是否转移到其他的服务器
上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。

报文的长度一旦超过限制，并不

会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没 有办法确定那几个报文段属于同一
个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求 报文。

DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全 的应答，因为应答可以被他人伪造，
所以现在有了 DNS over HTTPS 来解决这个问题。
详细资料可以参考：  《为什么 DNS  使用 UDP  而不是 TCP？》

5.3.6.  当你在浏览器中输入 Google.com  并且按下回车之后发生了什么？

IP 地址返回给请求的用

户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起 请求属于迭代请求。

(4) 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数 据给传输层，TCP 协议会指定源

端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址 作为目的地址。然后将下发给
数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址， 目的 MAC 地
址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请 求主机在同一个子网里，如果
在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子

中的公钥对随机数加密，然后
发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收 后，使用自己的私钥对数据解
密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个 随机数，按照之前所约定的加

密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后 再传输。

(7) 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到
响应后，开始对 html 文件进行
解析，开始页面的渲染过程。

务器将请求定位到最近的含有该资源

的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访 问压力。
详细资料可以参考：  《CDN  是什么？使用 CDN  有什么优势？》

5.3.8.  什么是正向代理和反向代理？

我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知
道真实的客户端是谁，客户端请求的
服务都被代理服务器代替来请求。

反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我 们服务，但具体是哪一台，我们不知
道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请 求转发到真实的服务器那里去。反向                                                      代理器一般用来实现负载平衡。
详细资料可以参考：《正向代理与反向代理有什么区别》《webpack  配置 proxy
反向代理的原理是什么？》

5.3.9.  负载平衡的两种实现方式？

务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以 有可能一个服务器出现故障后，域名解
析仍然返回的是那个 IP 地址，就会造成访问的问题。
详细资料可以参考：  《负载均衡的原理》

5.3.10. http  请求方法 options  方法有什么用？

OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务 器返回该资源所支持的所有 HTTP 请
求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能 是否正常。JS 的 XMLHttpRequest
对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以 判断是否有对指定资源的访问权限。
相关资料可以参考：  《HTTP  请求方法》

(5) http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。
详细资料可以参考：  《HTTP1.0、HTTP1.1  和 HTTP2.0  的区别》 《HTTP  协议 入门》 《网络---一篇文章详解请求头 Host  的概念》

5.3.12.  网站域名加 www  与不加 www  的区别？

详细资料可以参考：《为什么域名前要加 www  前缀 www  是什么意思？》《为 什么越来越多的网站域名不加「www」前缀？》《域名有 www  与没有 www  有
什么区别？》

5.3.13.  即时通讯的实现，短轮询、长轮询、SSE  和 WebSocket  间的区别？

优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于， 连接挂起也会导致资源的浪费。

SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务 器主动推送信息。但是，有一种变通

方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数 据包，而是一个数据流，会连续不断
地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就 是这样的例子。SSE 就是利用这种机
制，使用流信息向浏览器推送信息。它基于 http 协议， 目前除了 IE/Edge，其他浏览器都支 持。它相对于前面两种方式来说，不
需要建立过多的 http 请求，相比之下节约了资源。

上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。
WebSocket 是 Html5 定义的一个新协
议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket
协议的缺点是在服务器端的配置
比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，
而 SSE 的方式是单向通信的，只能
由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。
详细资料可以参考：《轮询、长轮询、长连接、websocket》《Server-Sent Events 教程》 《WebSocket  教程》

5.3.14.  怎么实现多个网站之间共享登录状态

心，该认证中心的作用是判断客户端发
送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密 的登录信息的 token 给客户端，该
token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式 来传递 token，然后转移到的应用站
点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端 返回对应的用户信息，如果失效了则将

页面重定向会单点登录页面。
